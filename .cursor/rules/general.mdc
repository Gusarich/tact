---
description: Project Overview, Repository Structure and Development Workflow 
globs: **/*
---
## Overview
This repository contains the Tact smart contract programming language, which transpiles to FunC and compiles down to TVM bytecode.

The Tact compiler processes `.tact` source files through the following stages:
- Parsing into an Abstract Syntax Tree (AST).
- Type-checking and semantic validation.
- Transpilation into FunC, followed by compilation to Fift and TVM bytecode in BoC (Bag of Cells) format.
- Generation of TypeScript wrappers for testing contracts in a simulated blockchain environment.
- Production of Markdown and JSON summaries, including contract storage layouts, TL-B schemas, and exit codes.

Tact is implemented in TypeScript and requires Node.js 22 or later. The compiler relies on a patched version of the FunC compiler, which is vendored as a WASM binary.

## Repository Structure

### Root-Level Folders
- `/bin/` – Command-line interface entry points.
- `/dev-docs/` – Developer documentation, including [CHANGELOG.md](mdc:dev-docs/CHANGELOG.md), [CONTRIBUTING.md](mdc:dev-docs/CONTRIBUTING.md) and [STYLEGUIDE.md](mdc:dev-docs/STYLEGUIDE.md).
- `/docs/` – User documentation and guides.
- `/examples/` – Example Tact contracts and usage scenarios.
- `/spell/` – Spellchecker ignore lists.
- `/src/` – Compiler components.
- `/.github/` – CI/CD workflows and GitHub-specific configurations.

### Compiler Components (`/src/` folder)
- `/src/abi/` – Type-checking and generation of functions, including `global.ts`, `map.ts`, and `struct.ts`.
- `/src/ast/` – Abstract Syntax Tree (AST) definitions, primarily in `ast.ts`.
- `/src/bindings/` – Code generation for smart contract wrappers.
- `/src/cli/` – Command-line interface implementation.
- `/src/config/` – Configuration management, including `tact.config.json` schema definitions.
- `/src/context/` – Compiler context management.
- `/src/error/` – Error message definitions for the compiler.
- `/src/func/` – FunC integration and transpilation logic, with the main implementation in `funcCompile.ts`.
- `/src/generate/` – Transpiled FunC code generation, with an entry point in `writeProgram.ts`.
- `/src/grammar/` – Grammar definitions:
  - `prev/` and `next/` versions are maintained concurrently.
- `/src/imports/` – Import resolution for Tact smart contract sources.
- `/src/optimizer/` – Smart contract optimizations, including constant evaluation.
- `/src/packaging/` – `.pkg` package generation for compiled contracts.
- `/src/pipeline/` – Compiler pipeline:
  - `build.ts` – High-level compilation logic.
  - `precompile.ts` – Import resolution, type-checking, and schema generation.
- `/src/server/` – Tact compiler server for custom error logging.
- `/src/stdlib/` – Standard library:
  - `std/` – Automatically loaded ambient definitions.
  - `libs/` – Importable standard library modules (`@stdlib/...`).
- `/src/storage/` – Smart contract persistent storage allocations.
- `/src/test/` – Compiler tests:
  - `benchmarks/` – Performance benchmarks and gas optimization tracking.
  - `codegen/` – Ensures successful compilation without runtime tests, often used for FunC bug fixes.
  - `compilation-failed/` – Ensures failed compilations produce correct error messages.
  - `contracts/` – Tact smart contracts for testing the pretty-printer.
  - `e2e-emulated/` – End-to-end testing of smart contracts, message interactions, and get method calls.
  - `exit-codes/` – Tests for specific TVM exit codes.
- `/src/types/` – Type-checking system:
  - `resolveDescriptors.ts` – Validates module-level items.
  - `resolveStatements.ts` – Ensures statement correctness.
  - `resolveExpression.ts` – Type-checks expressions.
- `/src/utils/` – Utility functions, including `crc16.ts`, `crc32.ts`, `sha256.ts` and other.
- `/src/vfs/` – Virtual file system for controlled FunC compiler interaction.

## Development Workflow

When making changes to the codebase, follow this standard process to ensure correctness and maintainability:

1. Edit the codebase
   Make your modifications to the relevant files.

2. Check for linting and other issues
   Run:
   `yarn lint:all`
   This checks for ESLint violations, Prettier formatting issues, spelling errors, and unused dependencies.
   Fix any issues and re-run the command until the checks pass.

3. Regenerate necessary files
   Depending on what was changed, run the appropriate `yarn gen` command:
   - General regeneration (most common step after edits):
     `yarn gen`
     This regenerates grammar files, the standard library, FunC bindings, and contract wrappers.
   - Specific regeneration commands:
     - `yarn gen:stdlib` – After modifying files in `src/stdlib/`.
     - `yarn gen:grammar` – After modifying `src/grammar/`.
     - `yarn gen:func-js` – After modifying FunC transpilation logic.
     - `yarn gen:contracts:test` – After adding or modifying test contracts.
     - `yarn gen:contracts:benchmarks` – After adding new benchmark contracts.

   Note: `yarn build` is generally only needed when modifying CLI-related components. If you change the CLI behavior, run:
   `yarn build`

4. Run relevant tests
   - If your changes only affect a specific part of the codebase, run targeted tests:
     - Grammar parsing:
       `yarn test grammar`
     - Type checking:
       `yarn test resolve`
     - Standard library functions:
       `yarn test stdlib`
     - Map-related features:
       `yarn test map`
     - End-to-end contract execution:
       `yarn test e2e-emulated`
     - Error handling and exit codes:
       `yarn test exit-codes`
   - If your changes could impact multiple parts, it is recommended to run all tests:
     `yarn test`
   - Before running tests, ensure all necessary files are up to date by running:
     `yarn gen && yarn test`

5. Update test snapshots if necessary
   Many tests rely on Jest snapshots, which may need to be updated if expected outputs change.
   - To update snapshots while running tests, add the `-u` flag:
     `yarn test -u`
   - Before updating snapshots, carefully review the changes to ensure they acorrect.

Following this structured workflow helps maintain consistency, catch issues early, and prevent regressions.
